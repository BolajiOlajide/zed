<task_description>

The user wants to make a change to their codebase. Your task is to describe the change using
the following XML structure:

- <patch> - A group of related code changes.
  Includes the following child tags:
    - <title> (required) - A short, high-level description of the changes.
    - <edit> (1 or more) - An edit to make at a particular location within the file.
      Includes the following child tags:
        - <path> (required) - The path to the file that will be changed.
        - <description> (optional) - An arbitrarily-long comment that describes the purpose of this edit.
        - <old_text> (optional) - An excerpt from the file's current contents that uniquely
          identifies a particular range within the file where an edit should occur. If this
          tag is not specified, then the entire file will be used as the location of the edit.
        - <new_text> (required) - The new text to insert at the given location in the file.
        - <operation> (required) - The type of change that should happen at this range of the file.
          Must be one of the following values:
            - `update`: Rewrites the specified string entirely based on the given description.
            - `create`: Creates a new file with the given path based on the provided description.
            - `insert_before`: Inserts new text based on the given description before the specified search string.
            - `insert_after`: Inserts new text based on the given description after the specified search string.
            - `delete`: Deletes the specified string from the containing file.

<guidelines>
- Only reference locations that actually exist (unless you're creating a file).
- If creating a file, assume any subsequent updates are included at the time of creation.
- Don't create and then update a file. Always create new files in one shot.
- Prefer multiple edits to smaller regions, as opposed to one big edit to a larger region.
- Don't produce edits that intersect each other. In that case, merge them into one edit.
- Never nest an edit with another edit.
- There's no need to escape angle brackets within tags.
- Always ensure imports are added if you're referencing symbols that are not in scope.
</guidelines>

Here are some concrete examples.

<example>
<message role="user">

```rs src/shapes.rs
pub mod rectangle;
pub mod circle;
```

```rs src/shapes/rectangle.rs
pub struct Rectangle {
    width: f64,
    height: f64,
}

impl Rectangle {
    pub fn new(width: f64, height: f64) -> Self {
        Rectangle { width, height }
    }
}
```

```rs src/shapes/circle.rs
pub struct Circle {
    radius: f64,
}

impl Circle {
    pub fn new(radius: f64) -> Self {
        Circle { radius }
    }
}
```

Update all shapes to store their origin as an (x, y) tuple and implement Display.
</message>

<message role="assistant">
We'll need to update both the rectangle and circle modules.

<patch>
<title>Add origins and display impls to all shapes</title>
<edit>
<path>src/shapes/rectangle.rs</path>
<description>Add the origin field to Rectangle struct</description>
<operation>insert_after</operation>
<old_text>
pub struct Rectangle {
</old_text>
<new_text>
origin: (f64, f64),
</new_text>
</edit>

<edit>
<path>src/shapes/rectangle.rs</path>
<description>Update the Rectangle's new function to take an origin parameter</description>
<operation>update</operation>
<old_text>
fn new(width: f64, height: f64) -> Self {
    Rectangle { width, height }
}
</old_text>
<new_text>
fn new(origin: (f64, f64), width: f64, height: f64) -> Self {
    Rectangle { origin, width, height }
}
</new_text>
</edit>

<edit>
<path>src/shapes/circle.rs</path>
<description>Add the origin field to Circle struct</description>
<operation>insert_after</operation>
<old_text>
pub struct Circle {
    radius: f64,
</old_text>
<new_text>
    origin: (f64, f64),
</new_text>
</edit>

<edit>
<path>src/shapes/circle.rs</path>
<description>Update the Circle's new function to take an origin parameter</description>
<operation>update</operation>
<old_text>
fn new(radius: f64) -> Self {
    Circle { radius }
}
</old_text>
<new_text>
fn new(origin: (f64, f64), radius: f64) -> Self {
    Circle { origin, radius }
}
</new_text>
</edit>
</step>

<edit>
<path>src/shapes/rectangle.rs</path>
<description>Add an import for the std::fmt module</description>
<operation>insert_before</operation>
<old_text>
struct Rectangle {
</old_text>
<new_text>
use std::fmt;

</new_text>
</edit>

<edit>
<path>src/shapes/rectangle.rs</path>
<description>Add a Display implementation for Rectangle</description>
<operation>insert_after</operation>
<old_text>
        Rectangle { width, height }
    }
}
</old_text>
<new_text>
impl fmt::Display for Rectangle {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.format_struct(f, "Rectangle")
            .field("origin", &self.origin)
            .field("width", &self.width)
            .field("height", &self.height)
            .finish()
    }
}
</new_text>
</edit>

<edit>
<path>src/shapes/circle.rs</path>
<description>Add an import for the `std::fmt` module</description>
<operation>insert_before</operation>
<old_text>
struct Circle {
</old_text>
<new_text>
use std::fmt;
</new_text>
</edit>

<edit>
<path>src/shapes/circle.rs</path>
<description>Add a Display implementation for Circle</description>
<operation>insert_after</operation>
<old_text>
        Circle { radius }
    }
}
</old_text>
<new_text>
impl fmt::Display for Rectangle {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.format_struct(f, "Rectangle")
            .field("origin", &self.origin)
            .field("width", &self.width)
            .field("height", &self.height)
            .finish()
    }
}
</new_text>
</edit>
</patch>

</message>
</example>

</task_description>
