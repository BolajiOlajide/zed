<task_description>

To suggest edits to source code files, provide a `<patch>` XML tag. The `<patch>` tag should contain one or more `<edit>` tags with the following child tags:

### `<description>` (required)

This tag contains a single-line description of the edit that should be made at the given location.

### `<path>` (required)

This tag contains the path to the file that will be changed. It can be an existing path, or a path that should be created.

### `<old_text>` (optional)

This tag contains a search string to locate in the source file, e.g. `pub fn baz() {`. If not provided, the new content will be inserted at the top of the file. Make sure to produce a string that exists in the source file and that isn't ambiguous. When there's ambiguity, add more lines to the search to eliminate it.

### `<operation>` (required)

This tag indicates what type of change should be made, relative to the given location. It can be one of the following:
- `update`: Rewrites the specified string entirely based on the given description.
- `create`: Creates a new file with the given path based on the provided description.
- `insert_before`: Inserts new text based on the given description before the specified search string.
- `insert_after`: Inserts new text based on the given description after the specified search string.
- `delete`: Deletes the specified string from the containing file.

### `<new_text>` (required)

This tag should contain the new text to insert at the given location in the file.

## Example 1

<patch>
<edit>
<description>Add the age field</description>
<path>src/person.rs</path>
<operation>insert_before</operation>
<old_text>
height: f32,
</old_text>
<new_text>
age: usize,
</new_text>
</edit>

<edit>
<description>Add the age getter</description>
<path>src/person.rs</path>
<operation>insert_after</operation>
<old_text>
impl Person {
</old_text>
<new_text>
fn age(&self) -> usize {
    self.age
}
</new_text>
</edit>
</patch>

<guidelines>
- Only reference locations that actually exist (unless you're creating a file).
- If creating a file, assume any subsequent updates are included at the time of creation.
- Don't create and then update a file. Always create new files in one shot.
- Prefer multiple edits to smaller regions, as opposed to one big edit to a larger region.
- Don't produce edits that intersect each other. In that case, merge them into a bigger edit.
- Never nest an edit with another edit. Never include CDATA. All edits are leaf nodes.
- Descriptions are required for all edits except delete.
- When generating multiple edits, ensure the descriptions are specific to each individual operation.
- Avoid referring to the search string in the description. Focus on the change to be made, not the location where it's made. That's implicit with the `search` string you provide.
- Don't generate multiple edits at the same location. Instead, combine them together in a single edit with a succinct combined description.
- Always ensure imports are added if you're referencing symbols that are not in scope.
</guidelines>

Here are some concrete examples.

<example>
<message role="user">

```rs src/shapes.rs
pub mod rectangle;
pub mod circle;
```

```rs src/shapes/rectangle.rs
pub struct Rectangle {
    width: f64,
    height: f64,
}

impl Rectangle {
    pub fn new(width: f64, height: f64) -> Self {
        Rectangle { width, height }
    }
}
```

```rs src/shapes/circle.rs
pub struct Circle {
    radius: f64,
}

impl Circle {
    pub fn new(radius: f64) -> Self {
        Circle { radius }
    }
}
```

Update all shapes to store their origin as an (x, y) tuple and implement Display.
</message>

<message role="assistant">
We'll need to update both the rectangle and circle modules.

<patch>
<edit>
<description>Add the origin field to Rectangle</description>
<path>src/shapes/rectangle.rs</path>
<operation>insert_before</operation>
<old_text>
width: f64,
height: f64,
</old_text>
<new_text>
origin: (f64, f64),
</new_text>
</edit>

<edit>
<description>Update the Rectangle new function to take an origin</description>
<path>src/shapes/rectangle.rs</path>
<operation>update</operation>
<old_text>
fn new(width: f64, height: f64) -> Self {
    Rectangle { width, height }
}
</old_text>
<new_text>
fn new(origin: (f64, f64), width: f64, height: f64) -> Self {
    Rectangle { origin, width, height }
}
</new_text>
</edit>

<edit>
<description>Add the origin field to Circle</description>
<path>src/shapes/circle.rs</path>
<operation>insert_before</operation>
<old_text>
radius: f64,
</old_text>
<new_text>
origin: (f64, f64),
</new_text>
</edit>

<edit>
<description>Update the Circle new function to take an origin</description>
<path>src/shapes/circle.rs</path>
<operation>update</operation>
<old_text>
fn new(radius: f64) -> Self {
    Circle { radius }
}
</old_text>
<new_text>
fn new(origin: (f64, f64), radius: f64) -> Self {
    Circle { origin, radius }
}
</new_text>
</edit>
</step>

<edit>
<description>Add an import for the `std::fmt` module</description>
<path>src/shapes/rectangle.rs</path>
<operation>insert_before</operation>
<old_text>
struct Rectangle {
</old_text>
<new_text>
use std::fmt;
</new_text>
</edit>

<edit>
<description>Add a Display implementation for Rectangle</description>
<path>src/shapes/rectangle.rs</path>
<operation>insert_after</operation>
<old_text>
        Rectangle { width, height }
    }
}
</old_text>
<new_text>
impl fmt::Display for Rectangle {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.format_struct(f, "Rectangle")
            .field("origin", &self.origin)
            .field("width", &self.width)
            .field("height", &self.height)
            .finish()
    }
}
</new_text>
</edit>

<edit>
<description>Add an import for the `std::fmt` module</description>
<path>src/shapes/circle.rs</path>
<operation>insert_before</operation>
<old_text>
struct Circle {
</old_text>
<new_text>
use std::fmt;
</new_text>
</edit>

<edit>
<description>Add a Display implementation for Circle</description>
<path>src/shapes/circle.rs</path>
<operation>insert_after</operation>
<old_text>
        Circle { radius }
    }
}
</old_text>
<new_text>
impl fmt::Display for Rectangle {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.format_struct(f, "Rectangle")
            .field("origin", &self.origin)
            .field("width", &self.width)
            .field("height", &self.height)
            .finish()
    }
}
</new_text>
</edit>
</patch>

</message>
</example>

</task_description>
